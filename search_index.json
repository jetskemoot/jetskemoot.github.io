[["index.html", "Data science for Biology - Portfolio Jetske Moot 1 Introductie", " Data science for Biology - Portfolio Jetske Moot Jetske Moot May, 2025 1 Introductie Welkom bij mijn portfolio voor de cursus Workflows, onderdeel van Data Science for Biology 2. In dit portfolio laat ik zien hoe ik tijdens de cursus heb gewerkt aan reproduceerbare data analyse binnen een biologische context. Het bevat voorbeelden van mijn werk en opgedane vaardigheden. De opdrachten zijn uitgewerkt in R Markdown. Ik nodig je uit om verder te kijken en een beeld te krijgen van mijn manier van werken. "],["curriculum-vitae.html", "2 Curriculum vitae 2.1 Over mij 2.2 Opleidingen 2.3 Projecten 2.4 Werkervaring 2.5 Vaardigheden", " 2 Curriculum vitae In dit onderdeel van mijn portfolio vind je mijn curriculum vitae, waarin mijn academische achtergrond, werkervaring en vaardigheden op het gebied van Life Sciences worden gepresenteerd. 2.1 Over mij Mijn naam is Jetske Moot en ik ben een Life Sciences student aan de Hogeschool Utrecht, met een specialisatie in moleculaire biologie en data science. Ik heb een sterke interesse in onderwerpen zoals celkweek, cell viability, nanoplastics, lipidenmetabolisme en apoptose, die de kern vormen van mijn specialisatie onderzoek. Ik ben gemotiveerd om mijn kennis op deze gebieden te verdiepen en toe te passen in wetenschappelijk onderzoek. Ik benader mijn werk met nieuwsgierigheid, een kritisch denkvermogen en een sterk verantwoordelijkheidsgevoel. Naast mijn studie zwem ik op hoog nationaal niveau, wat mij heeft geholpen om discipline, doorzettingsvermogen en goede planningsvaardigheden te ontwikkelen. 2.2 Opleidingen Bachelor Life Sciences Hogeschool Utrecht, 2022 - heden - Specialisatie in biomolecular research - Minor in data science for biology - Propedeuse behaald in het eerste jaar Bachelor Fysiotherapie Hogeschool Utrecht, 2021 - 2022 - Propedeuse behaald in het eerste jaar Voortgezet onderwijs Centre for Sports and Education, Zwolle, 2016 - 2021 - HAVO diploma behaald 2.3 Projecten Onderzoek naar de effecten van polystyreen nanoplastics op het ceramide metabolisme in C3A en Hepa levercellen 2024-2025 Onderzoek uitgevoerd naar de invloed van polystyreen nanoplastics op het ceramidemetabolisme en apoptose in humane (C3A) en muis (Hepa) levercellen. Ik vergeleek de effecten van ongemodificeerde en met aminogroep gemodificeerde nanoplastics op het ceramidemetabolisme en hun potentieel om apoptose te induceren. Ik maakte gebruik van fluorescentiemicroscopie, HPLC-analyse en een Annexin Red apoptose assay om te onderzoeken hoe deze oppervlakte modificaties de intracellulaire lokalisatie, lipidesynthese en apoptose beïnvloeden. RNA-sequencing en differentiële genexpressieanalyse 2024-2025 Analyse uitgevoerd op paired-end RNA-sequencing data om genexpressieverschillen te identificeren tijdens de transdifferentiatie van fibroblasten naar neuronale cellen onder invloed van de transcriptiefactor ONECUT3. De workflow omvatte kwaliteitscontrole, read alignment, transcriptkwantificatie en differentiële genexpressieanalyse in R. Om de biologische relevantie te interpreteren, werd een Gene Ontology (GO) enrichment analyse uitgevoerd op de geïdentificeerde genen, met de focus op biologische processen. 2.4 Werkervaring Fabienne Chapot 2025 - heden Stylist ZPC Amersfoort wedstrijdzwemmen 2020 - heden Topsporter en begeleider clinics Woonzorg Flevoland 2022 - 2024 Gastvrouw bij een verzorgingstehuis voor ouderen Bakkerij Albert Heijn 2021 - 2022 2.5 Vaardigheden 2.5.1 Laboratoriumvaardigheden - Celkweek - Cell viability - (Fluorescentie)microscopie - Moleculaire biologische technieken - Experimenteel ontwerp - HPLC-analyse 2.5.2 Data-analyse vaardigheden R - Statistiek - Visualisatie - RNA-seq analyse - Reproduceerbare analyses met RMarkdown - Versiebeheer met Git/GitHub Bash - Scripting: functies, conditionals, loops SQL - Werken met relational databases 2.5.3 Talen Nederlands Moedertaal Engels Vloeiend (zowel geschreven als gesproken) "],["plan-voor-de-toekomst.html", "3 Plan voor de toekomst 3.1 Toekomstbeeld en huidig beeld", " 3 Plan voor de toekomst Voor dit onderdeel van mijn portfolio is ruimte gecreëerd om een nieuwe vaardigheid aan te leren die relevant is binnen het vakgebied van Data Science for Biology. Ik reflecteer op mijn ambities voor de komende jaren, analyseer welke kennis en competenties ik al bezit en welke ik verder zal moeten ontwikkelen. Deze zelfanalyse vormt de basis voor het gericht kiezen en ontwikkelen van een nieuwe vaardigheid, waarmee ik zowel mijn vaardigheden als mijn cv kan versterken. 3.1 Toekomstbeeld en huidig beeld Over 1 à 2 jaar zie ik mezelf werkzaam binnen een onderzoeksomgeving waarin biomedisch of moleculair biologisch onderzoek centraal staat. Een ideale positie zal zijn waar ik zowel experimenteel werk als data analyse combineer. Hierbij denk ik aan de ontwikkeling van nieuwe therapieën, het onderzoeken van ziektemechanismen of het verbeteren van behandelstrategieën. Mijn droombaan is dan ook een functie waarin ik niet alleen bijdraag aan het genereren van biologische data, maar deze ook kan interpreteren om tot nieuwe inzichten te komen die uiteindelijk de zorg kunnen verbeteren. Op dit moment heb ik een stevige basis opgebouwd in laboratoriumwerk en data analyse. Ik heb ervaring met celkweek, cell viability assays en diverse analysetechnieken, zoals fluorescentiemicroscopie en HPLC, evenals andere moleculaire biologische technieken. Deze vaardigheden stellen me in staat om de biologische processen te begrijpen die ten grondslag liggen aan ziekten of therapeutische responsen. Op het gebied van data analyse heb ik ervaring met R en Bash, waarmee ik biologische datasets kan verwerken, statistische analyses kan uitvoeren en resultaten kan visualiseren. Deze vaardigheden zijn van belang om experimenten te interpreteren en betrouwbare conclusies te trekken die bijdragen aan biomedisch onderzoek. Er zijn echter ook vaardigheden die ik verder wil ontwikkelen. Zo wil ik de komende jaren ervaring opdoen met organoidmodellen, omdat deze biologisch realistischere systemen bieden voor ziektestudies. Dit is een gebied waar ik nog niet veel ervaring mee heb, maar waar ik mij in de toekomst zeker verder in wil verdiepen. Daarnaast wil ik mijn data analyse vaardigheden uitbreiden door mij te verdiepen in eiwit analyse en visualisatie. Het begrijpen van eiwitstructuren is van groot belang, omdat de structuur van een eiwit invloed heeft op zijn functie, interacties en rol in ziektemechanismen. Het leren werken met het Bio3D package via de tutorial ‘Beginning Structure Analysis’ sluit hier perfect op aan. Bio3D biedt tools om eiwitstructuren te analyseren, visualiseren en te vergelijken. Dit helpt mij bij het interpreteren van de structurele impact van mutaties, bijvoorbeeld in ziekte geassocieerde eiwitten en bij het voorspellen van mogelijke therapeutische targets. Daarnaast zie ik deze kennis als een goede voorbereiding op het werken met geavanceerde voorspellende modellen zoals AlphaFold, dat de 3D structuur van eiwitten kan voorspellen op basis van aminozuursequenties. Bio3D biedt mij een basis om AlphaFold uiteindelijk beter te begrijpen en toe te passen. Door mezelf te verdiepen in deze technieken, streef ik ernaar goed voorbereid de arbeidsmarkt te betreden en een waardevolle bijdrage te leveren aan biomedisch onderzoek. "],["structurele-eiwitanalyse-met-bio3d.html", "4 Structurele eiwitanalyse met Bio3D 4.1 Mijn eerste ervaring met AlphaFold 4.2 Introductie Bio3D 4.3 Planning 4.4 Beginning Structure Analysis", " 4 Structurele eiwitanalyse met Bio3D Voor dit onderdeel van mijn portfolio is 32 uur aan zelfstudietijd beschikbaar gesteld voor het ontwikkelen van een nieuwe, zelfgekozen skill. Deze opdracht biedt de mogelijkheid om mijn vaardigheden gericht uit te breiden op een manier die aansluit bij mijn toekomstplannen in het onderzoek. In de onderstaande toelichting leg ik uit welke skill ik heb gekozen en hoe deze aansluit bij mijn toekomstambities. 4.1 Mijn eerste ervaring met AlphaFold AlphaFold, ontwikkeld door DeepMind, is een baanbrekend artificial intelligence (AI) model dat de driedimensionale (3D) structuur van eiwitten met hoge nauwkeurigheid kan voorspellen op basis van hun aminozuursequentie. Het model leert van vergelijkbare sequentiegegevens uit verschillende organismen. Het combineert kennis over hoe eiwitten zich vouwen op basis van hun chemische eigenschappen. AlphaFold voorspelt hierdoor heel nauwkeurig hoe een eiwit er in 3D uitziet. Dit is een grote doorbraak in de studie van eiwitten. Tijdens mijn oriëntatie op structurele eiwitanalyse heb ik geprobeerd AlphaFold lokaal op mijn MacBook te installeren en gebruiken. Dit was best uitdagend, vanwege de grote hoeveelheid benodigde data en de installatie. Ik heb onder andere Linux-gebaseerde installatiescripts moeten aanpassen voor macOS, bash scripts herschreven en verschillende vereiste packages geïnstalleerd. Dit gaf me waardevol inzicht in hoe AlphaFold werkt en welke stappen nodig zijn om zo’n model te gebruiken. Waarom heb ik uiteindelijk gekozen voor Bio3D? Helaas bleek de volledige installatie van AlphaFold te zwaar voor mijn MacBook, met name vanwege de enorme hoeveelheid data die nodig is voor het gebruik van de AlphaFold database. De opslagbehoefte was niet haalbaar op mijn laptop. Daarom heb ik besloten om in plaats daarvan Bio3D te gebruiken. Dit is een lichtere, maar nog steeds krachtige tool is voor structurele eiwitanalyse. Ook is mogelijk Bio3D te draaien op R via mijn MacBook. Bovendien biedt Bio3D een uitstekende basis om eiwitstructuuranalyse te leren, wat mij in de toekomst beter zal voorbereiden op het werken met meer geavanceerde tools zoals AlphaFold. 4.2 Introductie Bio3D In mijn toekomstige carrière binnen biomedisch onderzoek is het analyseren en visualiseren van eiwitten en hun structuur essentieel voor het verkrijgen van inzicht in hun functie en interacties. Dit is cruciaal voor het begrijpen van ziektemechanismen en het ontwikkelen van therapieën. De Bio3D package biedt een uitgebreide set met tools voor de structurele analyse van eiwitten. Door deze technieken te beheersen, kan ik inzicht krijgen in de mechanismen waarmee eiwitten functioneren, hoe ze veranderen bij ziekten en hoe ze kunnen worden gemanipuleerd voor therapeutische doeleinden [@grantBio3dPackageComparative2006; @InstallingBio3D]. Met Bio3D kan ik de basis van eiwitstructuuranalyse leren, inclusief het vergelijken en alignen van eiwitstructuren. Dit is een cruciale vaardigheid voor het interpreteren van data in biomedisch onderzoek, omdat structurele veranderingen vaak een directe invloed hebben op de functie van een eiwit. Deze kennis kan bijdragen aan een beter begrip van ziektemechanismen, het identificeren van potentiële targets en de ontwikkeling van nieuwe behandelingsstrategieën. Voor deze opdracht ga ik specifiek aan de slag met de tutorial “Beginning Structure Analysis”, waarbij ik mij focus op het onderdeel waar de berekening van de Root Mean Sqaure Deviation (RMSD) wordt toegelicht. Na het volgen van dit onderdeel, zal ik de geleerde technieken toepassen op een onbekende dataset. Hierbij vergelijk ik twee eiwitten, waarvan 1 wildtype en 1 mutant, op basis van de RMSD. Vervolgens visualiseer en align ik deze structuren met behulp van PyMOL en r3dmol, om zo de structurele verschillen zowel kwantitatief als visueel te kunnen waarnemen. RMSD De RMSD tussen overeenkomstige atomen van twee eiwitketens is een veelgebruikte maat om de gelijkenis tussen twee eiwitstructuren te bepalen. Hoe kleiner de RMSD waarde, hoe meer de twee structuren op elkaar lijken [@revaWhatProbabilityChance1998]. De RMSD waarde in Ångström (Å) wordt berekend met de formule \\(RMSD = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} d_i^2}\\). Waarbij \\(n\\) het aantal overeenkomende atomen is en \\(d_i\\) de afstand is tussen het overeenkomstige atoom \\(i\\) van structuur 1 en structuur 2. Een RMSD van 0 Å duidt op twee identieke structuren. Een RMSD tussen 0 en 2 Å wijst op kleine structurele verschillen. Waarden tussen 2 en 3 Å wijzen op matige verschillen, die wijzen op veranderingen of functionele impact. Bij een RMSD groter dan 3 Å spreken we van aanzienlijke structurele afwijkingen [@carugoNormalizedRootmeanspuareDistance2001]. Naast RMSD kan Principal Component Analysis (PCA) worden toegepast om structurele verschillen in meerdere principal components te analyseren. PCA maakt het mogelijk om grootschalige variaties tussen de eiwitstructuren te visualiseren, zonder de RMSD afzonderlijk te hoeven interpreteren. De uiteindelijke structurele verschillen kunnen visueel worden weergegeven met behulp van PyMOL en r3dmol. 4.3 Planning Datum Fase Omschrijving Geschatte tijd 18-5 Oriëntatie Oriëntatie op Bio3D package, installatie van benodigde software (R, Bio3D, XQuartz), inlezen in documentatie en wetenschappelijke literatuur, verwerking in toekomstbeeld en introductie schrijven 6 uur 19-5 Basisstructuuranalyse Stapsgewijs doorlopen van de tutorial “Beginning Structure Analysis” (deel 1), testen van functies op voorbeelddata, inclusief documentatie van resultaten 6 uur 20-5 Verdieping &amp; visualisatie Vervolg van de tutorial met nadruk op structurele alignments, berekenen van RMSD, en genereren van visualisaties in PyMOL 6 uur 21-5 Analyse eigen dataset Toepassen van geleerde technieken op een wildtype en mutante eiwitstructuur, interpreteren van RMSD resultaten en visualiseren met PyMOL en r3dmol, verslaglegging 10 uur 22-5 Controle en afronding Controle en verbetering van scripts, nakijken van RMarkdown op leesbaarheid en consistentie en reflectie 4 uur Totale Geschatte Tijd - - 32 uur 4.4 Beginning Structure Analysis 4.4.1 Tutorial Set up # MacOS X installatie # install.packages(&quot;bio3d&quot;, dependencies=TRUE) library(bio3d) # De volgende packages zijn ook nodig voor het gebruik van Bio3D. Voor MacBook wordt aangeraden de volgende packages te installeren via brew. # brew install homebrew/science/muscle # brew install homebrew/science/netcdf # brew install homebrew/science/dssp # Via brew was dit voor mij echter geen succes. Ik heb ze via conda gedownload. # conda install -c bioconda muscle=3.8.1551 # conda install netcdf4 # conda install dssp RMSD berekening en PCA # Download some example PDB files ids &lt;- c(&quot;1TND_B&quot;,&quot;1AGR_A&quot;,&quot;1FQJ_A&quot;,&quot;1TAG_A&quot;,&quot;1GG2_A&quot;,&quot;1KJY_A&quot;) raw.files &lt;- get.pdb(ids) # Extract and align the chains we are interested in files &lt;- pdbsplit(raw.files, ids) pdbs &lt;- pdbaln(files) # Calculate sequence identity pdbs$id &lt;- basename.pdb(pdbs$id) seqidentity(pdbs) ## Calculate RMSD rmsd &lt;- rmsd(pdbs, fit=TRUE) rmsd ## 1TND_B 1AGR_A 1FQJ_A 1TAG_A 1GG2_A 1KJY_A ## 1TND_B 0.000 0.965 0.609 1.283 1.612 2.100 ## 1AGR_A 0.965 0.000 0.873 1.575 1.777 1.914 ## 1FQJ_A 0.609 0.873 0.000 1.265 1.737 2.042 ## 1TAG_A 1.283 1.575 1.265 0.000 1.687 1.841 ## 1GG2_A 1.612 1.777 1.737 1.687 0.000 1.879 ## 1KJY_A 2.100 1.914 2.042 1.841 1.879 0.000 # fit=TRUE: je meet alleen structurele verschillen. De ene structuur wordt eerst ruimtelijk uitgelijnd (superposed) op de andere. De rotatie- en translatieverschillen worden weggehaald, zodat alleen de interne structurele verschillen overblijven. # fit=FALSE: zonder uitlijning (fit=FALSE) zou een klein verschil in positionering al tot een hoge RMSD leiden. Principal Component Analysis (PCA) PC1 (47.41%), PC2 (25.98%), en PC3 (19.07%) verklaren samen ongeveer 92.5% van de totale structurele variatie (zie de plot rechtsonder). Dit betekent dat met alleen PC1 tot en met PC3 vrijwel alle belangrijke verschillen tussen de eiwitstructuren verklaard kunnen worden. Hoe verder twee punten van elkaar af liggen, hoe meer de structuren van elkaar verschillen op basis van de posities van de overeenkomstige atomen. Als een mutant en wildtype ver uit elkaar liggen, wijst dat op een grote structurele verandering. De kleur van de punten in de PCA plot gaan op basis van volgorde hoe je de eiwit PDB’s inleest, dus: Structuur Kleur in plot 1TND_B Zwart 1AGR_A Rood 1FQJ_A Groen 1TAG_A Blauw 1GG2_A Cyan 1KJY_A Paars De eiwitten 1TND_B, 1AGR_A, en 1FQJ_A lijken sterk op elkaar, gezien hun clustering. 1KJY_A en 1GG2_A wijken hier sterk van af. PCA maakt duidelijk welke structuren functioneel gelijk zijn, zonder meteen alle individuele RMSD waarden te hoeven bekijken. ## Quick PCA pc &lt;- pca(pdbfit(pdbs), rm.gaps=TRUE) ## NOTE: Removing 37 gap positions with missing coordinate data ## retaining 313 non-gap positions for analysis. plot(pc, col = c(&quot;black&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;cyan&quot;, &quot;purple&quot;)) 4.4.2 RMSD en visualisatie op eigen datasets Na de tutorial “Beginning Structure Analysis”, is het de bedoeling om de geleerde stappen toe te passen op een eigen dataset. Hiervoor heb ik gekozen om twee verschillende eiwitten te analyseren, elk bestaande uit een wildtype en een bijbehorende mutantvariant. Op deze manier kon ik de structurele verschillen tussen wildtype en mutant in kaart brengen en leren hoe mutaties mogelijk invloed hebben op de eiwitstructuur en functie. De eerste dataset is bevat het anaplastisch lymfoomkinase (ALK) eiwit, ook bekend als de ALK tyrosine kinase receptor. Er is gekozen voor het wildtype structuur met PDB code “3L9P” en deze wordt vergeleken met de gemuteerde structuur “4FNX”, wat een puntmutatie bevat. ALK is een receptor tyrosine kinase die is betrokken bij celgroei en celdifferentiatie. De mutaties in ALK worden in verband gebracht met verschillende vormen van kanker. De tweede dataset is bevat het KRAS G-eiwit. Er is gekozen voor het wildtype structuur met PDB code “4OBE” en deze wordt vergeleken met de gemuteerde structuur “4TG9”, die een specifieke verandering in het GTP-bindend domein bevat. De mutatie in dit domein zorgt ervoor dat het eiwit actief blijft. De celgroei kan ongecontroleerd doorgaan en er kan kanker ontstaan. Door deze twee datasets te analyseren, kon ik ervaring opdoen met het vergelijken van eiwitstructuren, zowel visueel als kwantitatief. ALK RMSD en PCA # Download PDB files alk &lt;- c(&quot;3l9p&quot;,&quot;4fnx&quot;) raw.files_alk &lt;- get.pdb(alk) # Ruwe data komt standaard in de map terecht waar het R Markdown bestand in staat. # Extract and align the chains we are interested in files_alk &lt;- pdbsplit(raw.files_alk, alk) pdbs_alk &lt;- pdbaln(files_alk) # Calculate sequence identity pdbs_alk$id &lt;- basename.pdb(pdbs_alk$id) seqidentity(pdbs_alk) ## Calculate RMSD rmsd_alk &lt;- rmsd(pdbs_alk, fit=TRUE) rmsd_alk ## 3l9p_A 4fnx_A ## 3l9p_A 0.000 1.351 ## 4fnx_A 1.351 0.000 De RMSD van 1.399 Å is een reële, meetbare structurele afwijking tussen de twee eiwitten. Principal Component Analysis (PCA) PC1 (100%) verklaart de totale structurele variatie (zie de plot rechtsonder). Dit betekent dat met alleen PC1 alle belangrijke verschillen tussen de eiwitstructuren verklaard kunnen worden. De 2 punten liggen zo ver mogelijk uit elkaar. Als een mutant en wildtype ver uit elkaar liggen, wijst dat op een grote structurele verandering. In het geval van het ALK eiwit is dat dus zo. De afstand tussen de twee punten op de PC1-as is aanzienlijk en duidt op een reëel, meetbaar conformationeel verschil. De kleur van de punten in de PCA plot gaan op basis van volgorde hoe je de eiwit PDB’s inleest, dus: Structuur Kleur in plot 3l9p Blauw 4fnx Rood ## Quick PCA pc_alk &lt;- pca(pdbfit(pdbs_alk), rm.gaps=TRUE) ## NOTE: Removing 19 gap positions with missing coordinate data ## retaining 288 non-gap positions for analysis. plot(pc_alk, col = c(&quot;blue&quot;, &quot;red&quot;)) Uit de RMSD en PCA kan geconcludeerd worden dat het wildtype en de mutant van het ALK eiwit structueel varieeren. Met behulp van PyMOL en r3dmol kan gekeken worden naar wat voor effect dat heeft op de conformatie. Eiwit visualisatie met PyMOL en r3dmol Hieronder is de 3D visualisatie te zien van de alignment tussen de 2 eiwitten 3L9P en 4FNX. De 2 eiwitten representeren de structuur van een ALK kinase domein. De alignment is uitgevoegd in PyMOL en is vervolgens gedownload als PDB. De alignment is vervolgens met behulp van onderstaande code van de package r3dmol visueel gemaakt. Het wildtype eiwit 3L9P is blauw gekleurd, de mutant 4FNX wit. De plek van de mutatie, op aminozuur 1275, is rood gekleurd [@IntroductionR3dmol]. Vlak na de plek waar de mutatie is gekleurd wordt een structueel verschil gezien. Op deze plek van mutatie is te zien dat 4FNX ten opzichte van 3L9P een alpha-helix mist. Op basis van deze analyses kan geconcludeerd worden dat er wel degelijk een structureel verschil is tussen de 2 eiwitten. library(r3dmol) # alignment PDB bestanden inlezen als tekst aligned_pdb_3l9p &lt;- readLines(&quot;/Users/macbook12/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/protein_analysis/data/3l9p_aligned.pdb&quot;) aligned_pdb_4fnx &lt;- readLines(&quot;/Users/macbook12/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/protein_analysis/data/4fnx_aligned.pdb&quot;) r3dmol( viewer_spec = m_viewer_spec(cartoonQuality = 10, lowerZoomLimit = 50, upperZoomLimit = 350), id = &quot;alignment_3l9p_4fnx&quot;, elementId = &quot;alignment_3l9p_4fnx&quot;) |&gt; # eerste eiwitstructuur: 3L9P m_add_model(data = aligned_pdb_3l9p, format = &quot;pdb&quot;) |&gt; m_set_style(sel = m_sel(model = 0), style = m_style_cartoon(color = &quot;blue&quot;)) |&gt; # tweede eiwitstructuur: 4FNX m_add_model(data = aligned_pdb_4fnx, format = &quot;pdb&quot;) |&gt; m_set_style(sel = m_sel(model = 1), style = m_style_cartoon(color = &quot;white&quot;)) |&gt; # mutatieplek kleuren: op aminozuur 1275 m_set_style( sel = m_sel(resi = 1275, chain = &quot;A&quot;, model = 1), style = m_style_cartoon(color = &quot;red&quot;)) |&gt; # alignment tonen + toevoegen van draaien en zoomen op 3D figuur m_zoom_to() |&gt; m_spin() KRAS RMSD en PCA # Download PDB files kras &lt;- c(&quot;4obe_A&quot;, &quot;4tq9_A&quot;) raw.files_kras &lt;- get.pdb(kras) # Extract and align the chains we are interested in files_kras &lt;- pdbsplit(raw.files_kras, kras) pdbs_kras &lt;- pdbaln(files_kras) # Calculate sequence identity pdbs_kras$id &lt;- basename.pdb(pdbs_kras$id) pdbs_kras$id seqidentity(pdbs_kras) ## Calculate RMSD rmsd_kras &lt;- rmsd(pdbs_kras, fit=TRUE) rmsd_kras ## 4obe_A 4tq9_A ## 4obe_A 0.000 0.227 ## 4tq9_A 0.227 0.000 # fit=TRUE: je meet alleen structurele verschillen. De ene structuur wordt eerst ruimtelijk uitgelijnd (superposed) op de andere. De rotatie- en translatieverschillen worden weggehaald, zodat alleen de interne structurele verschillen overblijven. # fit=FALSE: zonder uitlijning (fit=FALSE) zou een klein verschil in positionering al tot een hoge RMSD leiden. Op basis van deze RSMD kan er niet geen structureel verschil verklaart worden. Principal Component Analysis (PCA) PC1 (100%) verklaart de totale structurele variatie (zie de plot rechtsonder). Dit betekent dat met alleen PC1 alle belangrijke verschillen tussen de eiwitstructuren verklaard kunnen worden. De 2 punten liggen zo ver mogelijk uit elkaar, echter is dit maar op een minimaal verschil (zie grafiek assen). Het oogt alsof er een groot verschil is, maar dat is daadwerkelijk niet zo. De kleur van de punten in de PCA plot gaan op basis van volgorde hoe je de eiwit PDB’s inleest, dus: Structuur Kleur in plot 4obe_A Blauw 4tq9_A Rood ## Quick PCA pc_kras &lt;- pca(pdbfit(pdbs_kras), rm.gaps=TRUE) ## NOTE: Removing 2 gap positions with missing coordinate data ## retaining 168 non-gap positions for analysis. plot(pc_kras, col = c(&quot;blue&quot;,&quot;red&quot;)) Uit de RMSD en PCA kan geconcludeerd worden dat het wildtype en de mutant van het KRAS eiwit structueel niet varieeren. Met behulp van PyMOL en r3dmol kan bekeken worden wat voor effect dat heeft op de conformatie. Eiwit visualisatie met PyMOL en r3dmol Hieronder is de 3D visualisatie te zien van de alignment tussen de 2 eiwitten 4OBE en 4TQ4. De 2 eiwitten representeren de structuur van het KRAS G-eiwit. De alignment is uitgevoegd in PyMOL en is vervolgens gedownload als PDB. De alignment is vervolgens met behulp van onderstaande code van de package r3dmol visueel gemaakt. Het wildtype eiwit 4OBE is blauw gekleurd, de mutant 4TQ4 wit. De plek van de mutatie, op aminozuur 12, is rood gekleurd. Er is geen visueel structureel verschil te zien in de alignment tussen wildtype en mutant. Het ontbreken van duidelijke structurele verschillen betekent niet dat de functie gelijk blijft. Toch zorgt deze mutatie namelijk voor ongecontroleerde celgroei en kanker. library(r3dmol) # alignment PDB bestanden inlezen als tekst aligned_pdb_4obe &lt;- readLines(&quot;/Users/macbook12/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/protein_analysis/data/4obeA_aligned.pdb&quot;) aligned_pdb_4tq9 &lt;- readLines(&quot;/Users/macbook12/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/protein_analysis/data/4tq9A_aligned.pdb&quot;) r3dmol( viewer_spec = m_viewer_spec(cartoonQuality = 10, lowerZoomLimit = 50, upperZoomLimit = 350), id = &quot;alignment_4obe_4tq4&quot;, elementId = &quot;alignment_4obe_4tq4&quot;) |&gt; # eerste eiwitstructuur: 4OBE m_add_model(data = aligned_pdb_4obe, format = &quot;pdb&quot;) |&gt; m_set_style(sel = m_sel(model = 0), style = m_style_cartoon(color = &quot;blue&quot;)) |&gt; # tweede eiwitstructuur: 4TQ4 m_add_model(data = aligned_pdb_4tq9, format = &quot;pdb&quot;) |&gt; m_set_style(sel = m_sel(model = 1), style = m_style_cartoon(color = &quot;white&quot;)) |&gt; # mutatieplek kleuren: op aminozuur 12 m_set_style( sel = m_sel(resi = 12, chain = &quot;A&quot;, model = 1), style = m_style_cartoon(color = &quot;red&quot;)) |&gt; # alignment tonen + toevoegen van draaien en zoomen op 3D figuur m_zoom_to() |&gt; m_spin() "],["guerrilla-analytics.html", "5 Guerrilla Analytics 5.1 DAUR2 5.2 Portfolio", " 5 Guerrilla Analytics In dit deel van mijn portfolio laat ik zien hoe ik de Guerilla Analytics richtlijnen toepas op data. 5.1 DAUR2 Hier laat ik mijn data management zien op de data voor de eindoprdacht van de cursus DAUR2 afkomstig uit Data Science for Biology 1. library(fs) fs::dir_tree(here::here(&quot;daur2_eindopdracht&quot;)) ## /Users/macbook12/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/daur2_eindopdracht ## ├── README.md ## ├── data ## │ ├── bam ## │ │ ├── SRR7866699.bam ## │ │ ├── SRR7866699.bam.indel.vcf ## │ │ ├── SRR7866699.bam.summary ## │ │ ├── SRR7866700.bam ## │ │ ├── SRR7866700.bam.indel.vcf ## │ │ ├── SRR7866700.bam.summary ## │ │ ├── SRR7866705.bam ## │ │ ├── SRR7866705.bam.indel.vcf ## │ │ ├── SRR7866705.bam.summary ## │ │ ├── SRR7866706.bam ## │ │ ├── SRR7866706.bam.indel.vcf ## │ │ └── SRR7866706.bam.summary ## │ ├── counts ## │ │ └── read_counts_OC3.rds ## │ └── fastqc ## │ ├── SRR7866699_1_fastqc.html ## │ ├── SRR7866699_1_fastqc.zip ## │ ├── SRR7866699_2_fastqc.html ## │ ├── SRR7866699_2_fastqc.zip ## │ ├── SRR7866700_1_fastqc.html ## │ ├── SRR7866700_1_fastqc.zip ## │ ├── SRR7866700_2_fastqc.html ## │ ├── SRR7866700_2_fastqc.zip ## │ ├── SRR7866705_1_fastqc.html ## │ ├── SRR7866705_1_fastqc.zip ## │ ├── SRR7866705_2_fastqc.html ## │ ├── SRR7866705_2_fastqc.zip ## │ ├── SRR7866706_1_fastqc.html ## │ ├── SRR7866706_1_fastqc.zip ## │ ├── SRR7866706_2_fastqc.html ## │ └── SRR7866706_2_fastqc.zip ## ├── daur2_eindopdracht.Rmd ## └── raw_data ## ├── fastq ## │ ├── SRR7866699_1.fastq.gz ## │ ├── SRR7866699_2.fastq.gz ## │ ├── SRR7866700_1.fastq.gz ## │ ├── SRR7866700_2.fastq.gz ## │ ├── SRR7866705_1.fastq.gz ## │ ├── SRR7866705_2.fastq.gz ## │ ├── SRR7866706_1.fastq.gz ## │ └── SRR7866706_2.fastq.gz ## └── onecut_sampledata_OC3.csv 5.1.1 README file Dit is de inhoud van de README file voor de data management voor de eindoprdacht van de cursus DAUR2. cat(readLines(&quot;daur2_eindopdracht/README.md&quot;), sep = &quot;\\n&quot;) ## ********************* ## ## PROJECT INFORMATIE ## ## ********************* ## ## **Titel** ## RNA-seq analyse van transdifferentiatie: ONECUT3 versus BCL2 in humane fibroblasten ## ## **Auteur informatie** ## *Principal Investigator* ## Naam: Timothy E. Reddy ## Instituut: Duke University ## ## *Co-Investigator* ## Naam: Jetske Moot ## Instituut: Hogeschool Utrecht ## ## *Datum van data collectie* ## Data gepubliceerd in 2019, verzameld in 2018 ## *Funder* ## National Institutes of Health (NIH) ## Grant ID: GM118650 ## ## ************************* ## ## DATA TOEGANG INFORMATIE ## ## ************************* ## ## **Licenties / beperkingen voor toegang tot de dataset** ## Vrij toegankelijk via NCBI GEO (open access) ## ## **Links naar publicaties die de data gebruiken** ## Black et al. (2019), Nucleic Acids Research ## DOI: https://doi.org/10.1093/nar/gkz224 ## ## **Links naar andere publiek toegankelijke locaties van de data** ## GEO: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122350 ## *SRA Run IDs* ## SRR7866699 (BCL2 replicate 1) ## SRR7866700 (BCL2 replicate 2) ## SRR7866705 (ONECUT3 replicate 1) ## SRR7866706 (ONECUT3 replicate 2) ## ## **************************** ## ## METHODEN VOOR DATA VERZAMELING ## ## **************************** ## ## **Methoden voor data verzameling** ## Menselijke fibroblasten werden getransduceerd met dCas9-VPR en specifieke gRNAs gericht op transcriptiefactoren. Voor deze dataset werd óf BCL2 óf ONECUT3 endogeen geactiveerd. 5 dagen na transductie werd RNA geïsoleerd en gesequencet. ## ## **Data processing methoden** ## Kwaliteitscontrole met FastQC ## Alignments met STAR aligner ## Feature quantificatie met featureCounts ## Analyse uitgevoerd in R met DESeq2 ## Analyse opgenomen in eindopdracht_daur2.Rmd ## ## **Instrument informatie** ## Illumina HiSeq 4000 ## Stranded paired-end sequencing (2 × 100 bp) ## ## **Quality assurance procedures** ## FastQC output beschikbaar in de directory /home/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/daur2_eindopdracht/data/fastqc ## ## **Analyse methoden** ## DESeq2 voor normalisatie en DGE ## PCA voor sample clustering ## Volcano plots en heatmaps ## GO-enrichment analysis ## ## ************************ ## ## SAMENVATTING VAN DATA BESTANDEN ## ## ************************ ## ## **Lijst van data bestanden** ## ## File naam Korte omschrijving ## ---------------------------------------------- ## onecut_sampledata_OC3.csv Sample metadata (behandeling, ID&#39;s) ## read_counts_OC3.rds R object met ruwe count matrix ## eindopdracht_daur2.Rmd Analyse- en visualisatie ## SRR7866699_1.fastq.gz Paired-end forward reads voor sample 1 ## SRR7866699_2.fastq.gz Paired-end reverse reads voor sample 1 ## SRR7866700_1.fastq.gz Paired-end forward reads voor sample 2 ## SRR7866700_2.fastq.gz Paired-end reverse reads voor sample 2 ## SRR7866705_1.fastq.gz Paired-end forward reads voor sample 3 ## SRR7866705_2.fastq.gz Paired-end reverse reads voor sample 3 ## SRR7866706_1.fastq.gz Paired-end forward reads voor sample 4 ## SRR7866706_2.fastq.gz Paired-end reverse reads voor sample 4 ## 5.2 Portfolio Hier laat ik mijn data management zien op de data van mijn portfolio voor Data Science for Biology 2. fs::dir_tree(here::here(&quot;../dsfb2_workflows_portfolio_jm&quot;)) ## /Users/macbook12/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/../dsfb2_workflows_portfolio_jm ## ├── 01_cv_jm.Rmd ## ├── 02_toekomst_jm.Rmd ## ├── 03_vrije_opdracht_jm.Rmd ## ├── 04_guerrilla_analytics.Rmd ## ├── 05_reproducible.Rmd ## ├── 06_rpackage.Rmd ## ├── 07_projecticum.Rmd ## ├── 08_covid19.Rmd ## ├── LICENSE ## ├── README.md ## ├── _book ## │ ├── 404.html ## │ ├── _main_files ## │ │ └── figure-html ## │ │ ├── threshold plotten-1.png ## │ │ ├── unnamed-chunk-10-1.png ## │ │ ├── unnamed-chunk-11-1.png ## │ │ ├── unnamed-chunk-12-1.png ## │ │ ├── unnamed-chunk-13-1.png ## │ │ ├── unnamed-chunk-14-1.png ## │ │ ├── unnamed-chunk-17-1.png ## │ │ ├── unnamed-chunk-17-2.png ## │ │ ├── unnamed-chunk-21-1.png ## │ │ ├── unnamed-chunk-22-1.png ## │ │ ├── unnamed-chunk-23-1.png ## │ │ ├── unnamed-chunk-24-1.png ## │ │ ├── unnamed-chunk-25-1.png ## │ │ ├── unnamed-chunk-28-1.png ## │ │ ├── unnamed-chunk-29-1.png ## │ │ ├── unnamed-chunk-31-1.png ## │ │ ├── unnamed-chunk-35-1.png ## │ │ ├── unnamed-chunk-36-1.png ## │ │ ├── unnamed-chunk-37-1.png ## │ │ ├── unnamed-chunk-38-1.png ## │ │ ├── unnamed-chunk-40-1.png ## │ │ ├── unnamed-chunk-41-1.png ## │ │ ├── unnamed-chunk-42-1.png ## │ │ ├── unnamed-chunk-43-1.png ## │ │ ├── unnamed-chunk-44-1.png ## │ │ ├── unnamed-chunk-45-1.png ## │ │ ├── unnamed-chunk-46-1.png ## │ │ ├── unnamed-chunk-47-1.png ## │ │ ├── unnamed-chunk-8-1.png ## │ │ └── unnamed-chunk-9-1.png ## │ ├── curriculum-vitae.html ## │ ├── cv.html ## │ ├── ecdc-covid-19-geparametriseerd-rapport.html ## │ ├── guerrilla-analytics.html ## │ ├── images ## │ │ ├── alphafold_example.png ## │ │ └── bio3d_example.png ## │ ├── index.html ## │ ├── introduction.html ## │ ├── leren-van-alphafold---nauwkeurige-eiwitstructuur-voorspelling.html ## │ ├── leren-van-bio3d---structurele-eiwitanalyse.html ## │ ├── libs ## │ │ ├── anchor-sections-1.1.0 ## │ │ │ ├── anchor-sections-hash.css ## │ │ │ ├── anchor-sections.css ## │ │ │ └── anchor-sections.js ## │ │ ├── crosstalk-1.2.1 ## │ │ │ ├── css ## │ │ │ │ └── crosstalk.min.css ## │ │ │ └── js ## │ │ │ └── crosstalk.min.js ## │ │ ├── gitbook-2.6.7 ## │ │ │ ├── css ## │ │ │ │ ├── fontawesome ## │ │ │ │ │ └── fontawesome-webfont.ttf ## │ │ │ │ ├── plugin-bookdown.css ## │ │ │ │ ├── plugin-clipboard.css ## │ │ │ │ ├── plugin-fontsettings.css ## │ │ │ │ ├── plugin-highlight.css ## │ │ │ │ ├── plugin-search.css ## │ │ │ │ ├── plugin-table.css ## │ │ │ │ └── style.css ## │ │ │ └── js ## │ │ │ ├── app.min.js ## │ │ │ ├── clipboard.min.js ## │ │ │ ├── jquery.highlight.js ## │ │ │ ├── plugin-bookdown.js ## │ │ │ ├── plugin-clipboard.js ## │ │ │ ├── plugin-fontsettings.js ## │ │ │ ├── plugin-search.js ## │ │ │ └── plugin-sharing.js ## │ │ ├── htmltools-fill-0.5.8.1 ## │ │ │ └── fill.css ## │ │ ├── htmlwidgets-1.6.4 ## │ │ │ └── htmlwidgets.js ## │ │ ├── jquery-3.6.0 ## │ │ │ └── jquery-3.6.0.min.js ## │ │ ├── plotly-binding-4.10.4 ## │ │ │ └── plotly.js ## │ │ ├── plotly-htmlwidgets-css-2.11.1 ## │ │ │ └── plotly-htmlwidgets.css ## │ │ ├── plotly-main-2.11.1 ## │ │ │ └── plotly-latest.min.js ## │ │ ├── r3dmol-1.6.2 ## │ │ │ └── 3Dmol-nojquery-min.js ## │ │ ├── r3dmol-binding-0.1.2 ## │ │ │ └── r3dmol.js ## │ │ └── typedarray-0.1 ## │ │ └── typedarray.min.js ## │ ├── main.html ## │ ├── peer-review.html ## │ ├── plan-voor-de-toekomst.html ## │ ├── projecticum-alternative-splicing-scrna-seq.html ## │ ├── r-package.html ## │ ├── reproducible-science.html ## │ ├── search_index.json ## │ ├── structurele-eiwitanalyse-met-bio3d.html ## │ └── vrije-opdracht---titel-nader-te-bepalen.html ## ├── _bookdown_files ## ├── _main.Rmd ## ├── _main_files ## │ └── figure-html ## │ ├── threshold plotten-1.png ## │ ├── unnamed-chunk-10-1.png ## │ ├── unnamed-chunk-11-1.png ## │ ├── unnamed-chunk-12-1.png ## │ ├── unnamed-chunk-13-1.png ## │ ├── unnamed-chunk-14-1.png ## │ ├── unnamed-chunk-17-1.png ## │ ├── unnamed-chunk-17-2.png ## │ ├── unnamed-chunk-21-1.png ## │ ├── unnamed-chunk-22-1.png ## │ ├── unnamed-chunk-23-1.png ## │ ├── unnamed-chunk-24-1.png ## │ ├── unnamed-chunk-25-1.png ## │ ├── unnamed-chunk-28-1.png ## │ ├── unnamed-chunk-29-1.png ## │ ├── unnamed-chunk-31-1.png ## │ ├── unnamed-chunk-35-1.png ## │ ├── unnamed-chunk-36-1.png ## │ ├── unnamed-chunk-37-1.png ## │ ├── unnamed-chunk-38-1.png ## │ ├── unnamed-chunk-40-1.png ## │ ├── unnamed-chunk-41-1.png ## │ ├── unnamed-chunk-42-1.png ## │ ├── unnamed-chunk-43-1.png ## │ ├── unnamed-chunk-44-1.png ## │ ├── unnamed-chunk-45-1.png ## │ ├── unnamed-chunk-46-1.png ## │ ├── unnamed-chunk-47-1.png ## │ ├── unnamed-chunk-8-1.png ## │ └── unnamed-chunk-9-1.png ## ├── bibliography.json ## ├── daur2_eindopdracht ## │ ├── README.md ## │ ├── data ## │ │ ├── bam ## │ │ │ ├── SRR7866699.bam ## │ │ │ ├── SRR7866699.bam.indel.vcf ## │ │ │ ├── SRR7866699.bam.summary ## │ │ │ ├── SRR7866700.bam ## │ │ │ ├── SRR7866700.bam.indel.vcf ## │ │ │ ├── SRR7866700.bam.summary ## │ │ │ ├── SRR7866705.bam ## │ │ │ ├── SRR7866705.bam.indel.vcf ## │ │ │ ├── SRR7866705.bam.summary ## │ │ │ ├── SRR7866706.bam ## │ │ │ ├── SRR7866706.bam.indel.vcf ## │ │ │ └── SRR7866706.bam.summary ## │ │ ├── counts ## │ │ │ └── read_counts_OC3.rds ## │ │ └── fastqc ## │ │ ├── SRR7866699_1_fastqc.html ## │ │ ├── SRR7866699_1_fastqc.zip ## │ │ ├── SRR7866699_2_fastqc.html ## │ │ ├── SRR7866699_2_fastqc.zip ## │ │ ├── SRR7866700_1_fastqc.html ## │ │ ├── SRR7866700_1_fastqc.zip ## │ │ ├── SRR7866700_2_fastqc.html ## │ │ ├── SRR7866700_2_fastqc.zip ## │ │ ├── SRR7866705_1_fastqc.html ## │ │ ├── SRR7866705_1_fastqc.zip ## │ │ ├── SRR7866705_2_fastqc.html ## │ │ ├── SRR7866705_2_fastqc.zip ## │ │ ├── SRR7866706_1_fastqc.html ## │ │ ├── SRR7866706_1_fastqc.zip ## │ │ ├── SRR7866706_2_fastqc.html ## │ │ └── SRR7866706_2_fastqc.zip ## │ ├── daur2_eindopdracht.Rmd ## │ └── raw_data ## │ ├── fastq ## │ │ ├── SRR7866699_1.fastq.gz ## │ │ ├── SRR7866699_2.fastq.gz ## │ │ ├── SRR7866700_1.fastq.gz ## │ │ ├── SRR7866700_2.fastq.gz ## │ │ ├── SRR7866705_1.fastq.gz ## │ │ ├── SRR7866705_2.fastq.gz ## │ │ ├── SRR7866706_1.fastq.gz ## │ │ └── SRR7866706_2.fastq.gz ## │ └── onecut_sampledata_OC3.csv ## ├── dsfb2_workflows_portfolio_jm.Rproj ## ├── images ## ├── index.Rmd ## ├── protein_analysis ## │ ├── 1AGR.pdb ## │ ├── 1FQJ.pdb ## │ ├── 1GG2.pdb ## │ ├── 1KJY.pdb ## │ ├── 1TAG.pdb ## │ ├── 1TND.pdb ## │ ├── 3l9p.pdb ## │ ├── 4fnx.pdb ## │ ├── 4obe.pdb ## │ ├── 4tq9.pdb ## │ ├── aln.fa ## │ ├── data ## │ │ ├── 3l9p_aligned.pdb ## │ │ ├── 4fnx_aligned.pdb ## │ │ ├── 4obeA_aligned.pdb ## │ │ └── 4tq9A_aligned.pdb ## │ ├── own_protein_analysis.Rmd ## │ ├── protein_analysis_tutorial.Rmd ## │ └── split_chain ## │ ├── 1AGR_A.pdb ## │ ├── 1FQJ_A.pdb ## │ ├── 1GG2_A.pdb ## │ ├── 1KJY_A.pdb ## │ ├── 1TAG_A.pdb ## │ ├── 1TND_B.pdb ## │ ├── 3l9p_A.pdb ## │ ├── 4fnx_A.pdb ## │ ├── 4obe_A.pdb ## │ └── 4tq9_A.pdb ## ├── raw_data ## │ └── CE.LIQ.FLOW.062_Tidydata.xlsx ## └── repro_opdracht ## ├── README.txt ## ├── analysis ## │ ├── analysis_data ## │ │ ├── af_edc_clinvar.tsv ## │ │ ├── af_foldx_clinvar.tsv.gz ## │ │ ├── clinvar_all_uniprot_2023-06-03.tsv.gz ## │ │ ├── clinvar_gnomad_veps.tsv.gz ## │ │ ├── ddg2p_monoallelic_uniprot.txt ## │ │ ├── gene_to_uniprot_2023_02.tsv ## │ │ ├── huang_hi_predictions.tsv ## │ │ ├── omim_inheritance_2023-05-25.tsv ## │ │ ├── shihab_hi_predictions.tsv ## │ │ └── steinberg_hi_predictions.tsv ## │ ├── model_analysis.Rmd ## │ ├── panther ## │ │ ├── dn_list.txt ## │ │ ├── gof_list.txt ## │ │ ├── panther_enrichment_dn.txt ## │ │ └── panther_enrichment_gof.txt ## │ ├── predictions ## │ │ ├── pdn_svm_poly_2023-07-25.tsv ## │ │ ├── pgof_svm_poly_2023-07-25.tsv ## │ │ └── plof_svm_poly_2023-07-28.tsv ## │ ├── test_set ## │ │ ├── dn_test_pred.tsv ## │ │ ├── gof_test_pred.tsv ## │ │ └── lof_test_pred.tsv ## │ └── thresholds ## │ ├── dn_thresholds.tsv ## │ ├── gof_thresholds.tsv ## │ └── lof_thresholds.tsv ## ├── colab ## │ ├── fx ## │ │ ├── ddg_ranks.tsv ## │ │ ├── up_1.tsv ## │ │ ├── up_10.tsv ## │ │ ├── up_11.tsv ## │ │ ├── up_12.tsv ## │ │ ├── up_13.tsv ## │ │ ├── up_14.tsv ## │ │ ├── up_15.tsv ## │ │ ├── up_16.tsv ## │ │ ├── up_17.tsv ## │ │ ├── up_18.tsv ## │ │ ├── up_19.tsv ## │ │ ├── up_2.tsv ## │ │ ├── up_20.tsv ## │ │ ├── up_21.tsv ## │ │ ├── up_22.tsv ## │ │ ├── up_23.tsv ## │ │ ├── up_24.tsv ## │ │ ├── up_25.tsv ## │ │ ├── up_26.tsv ## │ │ ├── up_27.tsv ## │ │ ├── up_28.tsv ## │ │ ├── up_29.tsv ## │ │ ├── up_3.tsv ## │ │ ├── up_30.tsv ## │ │ ├── up_31.tsv ## │ │ ├── up_32.tsv ## │ │ ├── up_33.tsv ## │ │ ├── up_34.tsv ## │ │ ├── up_35.tsv ## │ │ ├── up_36.tsv ## │ │ ├── up_37.tsv ## │ │ ├── up_38.tsv ## │ │ ├── up_39.tsv ## │ │ ├── up_4.tsv ## │ │ ├── up_40.tsv ## │ │ ├── up_41.tsv ## │ │ ├── up_5.tsv ## │ │ ├── up_6.tsv ## │ │ ├── up_7.tsv ## │ │ ├── up_8.tsv ## │ │ └── up_9.tsv ## │ ├── logo ## │ │ └── hexlogo.png ## │ └── mapping ## │ ├── handle_pmech.tsv ## │ └── reference_set.tsv ## ├── models ## │ ├── dn_vs_lof_model.Rmd ## │ ├── functions.R ## │ ├── gof_vs_lof_model.Rmd ## │ ├── lof_vs_nonlof_model.Rmd ## │ └── model_data ## │ ├── dn_imputed_full_frame_prep.tsv ## │ ├── dom_class_2023-06.csv ## │ ├── gene_to_uniprot_2023_02.tsv ## │ ├── gof_imputed_full_frame_prep.tsv ## │ ├── lof_imputed_full_frame_prep.tsv ## │ ├── protNLM_2023_02.tsv.gz ## │ ├── proteome_features.tsv ## │ ├── seqmat.clustal ## │ └── uniprot_2023_02.fa ## └── supplement ## ├── table_S1.csv ## ├── table_S2.xlsx ## └── table_S3.xlsx 5.2.1 README file Dit is de inhoud van de README file voor de data management van dit portfolio. cat(readLines(&quot;README.md&quot;), sep = &quot;\\n&quot;) ## # DSFB2 Workflows Portfolio Jetske Moot ## ## ## Welkom in de repository van het DSFB2 Workflows Portfolio van Jetske Moot. ## *Hogeschool Utrecht, 2025* ## ## ## ## Inhoud ## ## ## Deze repository bevat een verzameling van de uitwerking van de portfolio opdrachten uitgevoerd tijdens de DSFB2 cursus. Het portfolio bestaat uit diverse R Markdown documenten, analyses, data sets en bijbehorende outputs, gestructureerd in mappen per opdracht of onderwerp. ## ## ## ## Overzicht bestanden en mappen ## ## ## | Bestandsnaam / Map | Korte omschrijving | ## |----------------------------------|----------------------------------------------------------------| ## | 01_cv_jm.Rmd | Curriculum vitae (R Markdown document) | ## | 02_toekomst_jm.Rmd | Plan voor de toekomst (R Markdown document) | ## | 03_vrije_opdracht_jm.Rmd | Vrije opdracht (R Markdown document) | ## | 04_guerrilla_analytics.Rmd | Guerrilla analytics opdracht (R Markdown document) | ## | 05_reproducible.Rmd | Reproduceerbare wetenschap (R Markdown document) | ## | 06_rpackage.Rmd | Ontwikkeling van een R package (R Markdown document) | ## | 07_projecticum.Rmd | Introductie projecticum opdracht (R Markdown document) | ## | 08_covid19.Rmd | Documentatie parameterized rapport COVID-19 data (R Mardown document) | ## | bibliography.json | Bibliografische referenties | ## | LICENSE | Licentie informatie | ## | README.md | Huidige readme (wat nu wordt gelezen) | ## | dsfb2_workflows_portfolio_jm.Rproj | RStudio project | ## | index.Rmd | Hoofdindex van het project (R Markdown document) | ## | raw_data/ | Map met ruwe data | ## | images/ | Map met afbeeldingen | ## | _book/ | Gebouwde HTML versie van het project (bookdown output) | ## | _bookdown_files/ | Ondersteunende bestanden voor bookdown | ## | _main_files/figure-html/ | Figuurafbeeldingen gebruikt in het project | ## | daur2_eindopdracht/ | Submap met RNA-seq data en analyse | ## | repro_opdracht/ | Submap met reproduceerbaarheid analyse | ## | protein_analysis | Submap met code voor eiwitanalyse (vrije opdracht) | ## ## ## ## ## Licentie ## ## ## Deze repository is gelicenseerd onder de MIT License. ## ## ## ## Contact ## ## ## Jetske Moot - GitHub Issues ## ## ## ---------------------------------------------------------------------------- ## ## Veel plezier met verkennen van mijn portfolio! "],["peer-review.html", "6 Peer review 6.1 Data analyse van C. elegans blootstelling 6.2 Reproduceerbaarheid van wetenschappelijk onderzoek", " 6 Peer review In dit onderdeel van mijn portfolio onderzoek ik de reproduceerbaarheid van zowel experimentele data als gepubliceerde wetenschappelijke artikelen. Ik presenteer twee opdrachten waarin ik heb geoefend met het analyseren en beoordelen van wetenschappelijke data in R. 6.1 Data analyse van C. elegans blootstelling Voor deze opdracht was het de bedoeling om de data van een collega laborant te analyseren, afkomstig van het HU lectoraat Innovative Testing in Life Sciences &amp; Chemistry. De data is verkregen door C. elegans bloot te stellen aan verschillende concentraties van diverse chemicaliën. Het doel was om de analyse reproduceerbaar uit te werken in een RMarkdown bestand. Inlezen van dataset in R # data inlezen met behulp van readxl package library(readxl) data_ce_liq_flow_062 &lt;- read_excel(&quot;~/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/raw_data/CE.LIQ.FLOW.062_Tidydata.xlsx&quot;) Controleren van datatype # controle van datatype en of de data goed is ingelezen typeof(data_ce_liq_flow_062$RawData) # double ## [1] &quot;double&quot; typeof(data_ce_liq_flow_062$compName) # character ## [1] &quot;character&quot; typeof(data_ce_liq_flow_062$compConcentration) # character ## [1] &quot;character&quot; De data types zijn als volgt: - RawData = double - compName = character - compConcentration = character Op basis van de eerder gegeven informatie over de variabelen van de analyse zou ik de volgende aanpassingen maken: - rawData = integer - compConcentration = double De data is over het algemeen goed ingelezen, maar de datatypen hadden beter ingeladen kunnen worden. rawData en compConcentration hebben namelijk het verkeerde datatype. Data type corrigeren # data typen corrigeren data_ce_liq_flow_062$RawData &lt;- as.integer(data_ce_liq_flow_062$RawData) data_ce_liq_flow_062$compConcentration &lt;- as.double(data_ce_liq_flow_062$compConcentration) # controle van datatype typeof(data_ce_liq_flow_062$RawData) # integer ## [1] &quot;integer&quot; typeof(data_ce_liq_flow_062$compConcentration) # double ## [1] &quot;double&quot; Scatterplot maken van data library(ggplot2) # scatterplot maken met de aangeleverde data ggplot(data = data_ce_liq_flow_062, aes(x = compConcentration, y = RawData)) + geom_point(aes(colour = compName, shape = expType)) + scale_x_log10() + geom_jitter(alpha = 0) + theme_minimal() Scatterplot maken met genormaliseerde data library(dplyr) # bepalen van gemiddelde van negatieve controle mean_negative &lt;- mean(data_ce_liq_flow_062$RawData[data_ce_liq_flow_062$expType == &quot;controlNegative&quot;], na.rm = TRUE) # normaliseren van ruwe data met gemiddelde van negatieve controle normaldata_ce_liq_flow_062 &lt;- data_ce_liq_flow_062 |&gt; mutate(RawData_normalised = RawData / mean_negative) # scatterplot maken met de genormaliseerde data ggplot(data = normaldata_ce_liq_flow_062, aes(x = compConcentration, y = RawData_normalised)) + geom_point(aes(colour = compName, shape = expType)) + scale_x_log10() + geom_jitter(alpha = 0) + theme_minimal() Analyse reflectie Voor de analyse is de data ingelezen, geïnspecteerd en gevisualiseerd met scatterplots waarin de concentratie van het chemicalie en het aantal nakomelingen van C. elegans per chemicalie wordt weergegeven. In dit experiment worden verschillende typen controles gebruikt: controlNegative, oftewel de negatieve controle, is gedaan met S-medium. De negatieve controle is een soort referentiepunt voor de achtergrond van het aantal namekomelingen van C. elegans zonder de aanwezigheid van een chemicalie. De negatieve controle wordt gebruikt om niet specifieke reacties en ruis te identificeren. Hiermee kan je de ruwe data mee corrigeren. controlPositive, oftewel de positieve controle, is gedaan met ethanol. De positieve controle is behandeling waarvan verwacht wordt dat deze een duidelijke, meetbare respons veroorzaakt. Hiermee kan er aangetoond worden dat C. elegans een respons heeft op de behandeling en instaat is om een respons te genereren en functioneert zoals we verwachten op deze controle. controlVehicle, oftewel de vehicle controle, is ethanol. Dit is hetzelfde oplosmiddel als gebruikt in de experimentele chemicaliën en in de positieve controle. Deze controle controleert de eventuele effecten van het oplosmiddel en kunnen hierdoor worden onderscheiden van de effecten van de experimentele chemicaliën. Nut van Normalisatie Door alle meetwaarden uit te drukken als fractie van de gemiddelde negatieve controlewaarde, worden verschillen die veroorzaakt worden door ruis genormaliseerd. Dit zorgt voor een betere en betrouwbaardere data analyse. De data is genormaliseerd ten opzichte van de negatieve controle om vergelijkbaarheid tussen condities te verbeteren. Ook hebben we een plan opgesteld voor een dose-response analyse met behulp van het drc package in R. Stappenplan voor een dose-response analyse met drc package in R 1. Installeer en laad drc package. install.packages(&quot;drc&quot;) library(drc) 2. Lees de data in en inspecteer de dataset. 3. Voorbereiden van dataset. 4. Visualiseren van ruwe data. 5. Kiezen van het model. - Selecteer een geschikt dose-response model, bijvoorbeeld een 4-parameter log-logistisch model. 6. Model toepassen op de data. 7. Bepalen van de IC50-waarde. 8. Visualiseren van de dose-response curve. 9. Interpreteren van de resultaten. 6.2 Reproduceerbaarheid van wetenschappelijk onderzoek In dit onderdeel van mijn portfolio beoordeel ik de reproduceerbaarheid van een zelf gekozen wetenschappelijk artikel, waarvan de R code beschikbaar is gesteld. Introductie van onderzoek Het artikel “Proteome-scale prediction of molecular mechanisms underlying dominant genetic diseases” van Badonyi en Marsh (2024) richt zich op het voorspellen van moleculaire mechanismen die ten grondslag liggen aan dominante genetische aandoeningen. Veel van deze aandoeningen worden veroorzaakt door mutaties die handelen via dominante negatieve (DN), gain-of-function (GOF) of loss-of-function (LOF) mechanismen. Het onderscheiden van deze mechanismen is belangrijk voor de ontwikkeling van gerichte therapieën. De onderzoekers ontworpen een driedelig statistisch model, bestaande uit support vector machine (SVM) binary classifiers, om te voorspellen of menselijke eiwitcoderende genen geassocieerd worden met DN, GOF of LOF moleculaire ziekten mechanismen. Het model werd getest met behulp van bekende biologische en klinische eigenschappen die aan deze mechanismen zijn gekoppeld. De resultaten tonen aan dat het model goed kan omgaan met onbekende data en nuttige inzichten biedt in de functionele eigenschappen van eiwitten die betrokken zijn bij verschillende ziekteprocessen. De onderzoeksvraag van dit onderzoek luidt als volgt: - Hoe kunnen SVM binary classifiers worden ingezet om te voorspellen of menselijke eiwitcoderende genen betrokken zijn bij dominant-negatieve (DN), gain-of-function (GOF) of loss-of-function (LOF) moleculaire ziektemechanismen, en welke inzichten bieden deze voorspellingen in de functionele eigenschappen van eiwitten die een rol spelen bij verschillende ziekteprocessen? 6.2.1 Beoordeling van onderzoek op reproduceerbaarheid Aan de hand van de volgende beoordelingscriteria zal ik beoordelen of het onderzoek reproduceerbaar is. Transparency Criteria Definition Response Study Purpose A concise statement in the introduction of the article, often in the last paragraph, that establishes the reason the research was conducted. Also called the study objective. Yes Data Availability Statement A statement, in an individual section offset from the main body of text, that explains how or if one can access a study’s data. The title of the section may vary, but it must explicitly mention data; it is therefore distinct from a supplementary materials section. Yes Data Location Where the article’s data can be accessed, either raw or processed. Open Science Framework Study Location Author has stated in the methods section where the study took place or the data’s country/region of origin. Yes; United Kingdom Author Review The professionalism of the contact information that the author has provided in the manuscript. Correspondence address Ethics Statement A statement within the manuscript indicating any ethical concerns, including the presence of sensitive data. Not present Funding Statement A statement within the manuscript indicating whether or not the authors received funding for their research. Yes Code Availability Authors have shared access to the most updated code that they used in their study, including code used for analysis. Yes (Open Science Framework) Aangezien er 7 van de 8 criteria afgevinkt kunnen worden, kan er gesteld worden dat dit onderzoek reproduceerbaar is. 6.2.2 Zelf de code reproduceren Bekijk de R code en beschrijf in je eigen woorden wat de R code doet. Beoordeel de leesbaarheid met een cijfer van 1 (= erg slecht) tot 5 (= erg goed). De code is relatief overzichtelijk, met een duidelijke opbouw per plot. In het begin wordt duidelijk uitgelegd wat de functie van de geschreven functies is, die later over de gehele code gebruikt zullen worden. Er is een goede structuur, maar de headers hadden informatiever kunnen zijn. Op een oogopslag zou ik de R code nu een 4 geven. Download de R code en data en maak een nieuw R project aan om de analyse te herhalen. Probeer minstens 1 figuur te reproduceren. Als je hierbij tegen errors aanloopt, probeer die dan te verbeteren en houd die verbeteringen bij. Beoordeel hierna de reproduceerbaarheid van de R code met een cijfer van 1 (= erg slecht) tot 5 (= erg goed). # setup library(rstatix) # https://rpkgs.datanovia.com/rstatix/ library(tidyverse) # https://www.tidyverse.org/ library(tidymodels) # https://www.tidymodels.org/ library(scales) # https://scales.r-lib.org/ library(patchwork) # https://patchwork.data-imaginist.com/ # functies opstellen voor analyse no_zero_trail &lt;- function(x) ifelse(x == 0, &#39;0&#39;, x) optimal_threshold &lt;- function(base_data) { # Determines the optimal threshold from threshold data. # Custom to this particular project. # # Args: # base_data (tibble): one of &#39;dn_thresholds&#39;, &#39;gof_thresholds&#39;, or # &#39;lof_thresholds&#39; # # Returns: # A single numeric representing the threshold of lowest distance. base_data |&gt; filter(.metric %in% c(&#39;sensitivity&#39;, &#39;specificity&#39;)) |&gt; pivot_wider(names_from = .metric, values_from = .estimate) |&gt; mutate(distance = sqrt((1 - sensitivity) ^ 2 + (1 - specificity) ^ 2)) |&gt; arrange(distance) |&gt; slice(1) |&gt; pull(.threshold) } run_estimate &lt;- function(base_data, primary, metric_func) { # Wrapper for bootstraps() and yardstick threshold-dependent estimators. # Custom to this particular project. # # Args: # base_data (tibble): a test data table with columns gene, class, .pred_* # primary (character): one of &#39;dn&#39;, &#39;gof&#39;, &#39;lof&#39; # metric_func: a yardstick function, such as sensitivity() # # Returns: # A tibble containing 90% boostrap confidence intervals for the metric. set.seed(2024) t &lt;- filter(thresholds, class == {{ primary }})$t secondary &lt;- case_when(primary == &#39;dn&#39; ~ &#39;lof&#39;, primary == &#39;gof&#39; ~ &#39;lof&#39;, primary == &#39;lof&#39; ~ &#39;non_lof&#39;) base_data |&gt; rename(.pred_primary = str_c(&#39;.pred_&#39;, primary)) |&gt; mutate(.pred_class = if_else(.pred_primary &gt; t, primary, secondary), .pred_class = factor(.pred_class, levels = c(primary, secondary))) |&gt; bootstraps(strata = class, times = 1000, apparent = TRUE) |&gt; mutate(result = map( splits, .progress = TRUE, .f = function(split, ...) { analysis(split) |&gt; metric_func(class, .pred_class) |&gt; select(term = .metric, estimate = .estimate) } )) |&gt; int_pctl(statistics = result, alpha = 0.1) |&gt; mutate(class = primary) |&gt; mutate_if(is.double, round, 3) } sens50 &lt;- function(threshold_data, class) { # function to map out threshold at which 50% sensitivity is reached. # # args: # threshold_data (tibble): a table containing columns .threshold, # .metric, .estimator, and .estimate # class (character): one of &#39;dn&#39;, &#39;gof&#39;, &#39;lof&#39; # # returns: # a single-row tibble with the threshold value t (and other metrics). t &lt;- threshold_data |&gt; filter(.metric == &#39;sensitivity&#39;, .estimate &gt;= 0.5) |&gt; filter(.estimate == min(.estimate)) |&gt; head(1) |&gt; pull(.threshold) threshold_data |&gt; filter(.threshold == t) |&gt; pivot_wider(names_from = .metric, values_from = .estimate) |&gt; mutate(class = class) |&gt; select(class, t = .threshold, accuracy, specificity, sensitivity, npv, ppv, j_index) } ci_paster &lt;- function(estimate, lower, upper) { # Helper to paste confidence intervals. # # Args: # estimate (numeric): a point estimate # lower (numeric): lower confidence interval # upper (numeric): upper confidence interval # # Returns: # A character formatted in this style: &quot;1.0 [0.95, 1.5]&quot; str_c(estimate, &#39; [&#39;, lower, &#39;,&#39;, upper, &#39;]&#39;) } # test data dn_test &lt;- read_tsv(&#39;~/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/repro_opdracht/analysis/test_set/dn_test_pred.tsv&#39;, col_types = &#39;cfnn&#39;) gof_test &lt;- read_tsv(&#39;~/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/repro_opdracht/analysis/test_set/gof_test_pred.tsv&#39;, col_types = &#39;cfnn&#39;) lof_test &lt;- read_tsv(&#39;~/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/repro_opdracht/analysis/test_set/lof_test_pred.tsv&#39;, col_types = &#39;cfnn&#39;) # inlezen van threshold data dn_thresholds &lt;- read_tsv(&#39;~/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/repro_opdracht/analysis/thresholds/dn_thresholds.tsv&#39;) gof_thresholds &lt;- read_tsv(&#39;~/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/repro_opdracht/analysis/thresholds/gof_thresholds.tsv&#39;) lof_thresholds &lt;- read_tsv(&#39;~/dsfb2_2025_jm/dsfb2_workflows_portfolio_jm/repro_opdracht/analysis/thresholds/lof_thresholds.tsv&#39;) # thresholds at which 50% sensitivity is reached on the test sets thresholds &lt;- bind_rows( sens50(dn_thresholds, class = &#39;dn&#39;), sens50(gof_thresholds, class = &#39;gof&#39;), sens50(lof_thresholds, class = &#39;lof&#39;) ) # assign thresholds to variables pdn_threshold &lt;- thresholds$t[1] pgof_threshold &lt;- thresholds$t[2] plof_threshold &lt;- thresholds$t[3] # run metrics of interest metric_tbl &lt;- bind_rows( # sensitivity run_estimate(dn_test, primary = &#39;dn&#39;, sensitivity), run_estimate(gof_test, primary = &#39;gof&#39;, sensitivity), run_estimate(lof_test, primary = &#39;lof&#39;, sensitivity), # specificity run_estimate(dn_test, primary = &#39;dn&#39;, specificity), run_estimate(gof_test, primary = &#39;gof&#39;, specificity), run_estimate(lof_test, primary = &#39;lof&#39;, specificity), # Matthews correlation coefficient run_estimate(dn_test, primary = &#39;dn&#39;, mcc), run_estimate(gof_test, primary = &#39;gof&#39;, mcc), run_estimate(lof_test, primary = &#39;lof&#39;, mcc), # F1 score run_estimate(dn_test, primary = &#39;dn&#39;, f_meas), run_estimate(gof_test, primary = &#39;gof&#39;, f_meas), run_estimate(lof_test, primary = &#39;lof&#39;, f_meas), # accuracy run_estimate(dn_test, primary = &#39;dn&#39;, accuracy), run_estimate(gof_test, primary = &#39;gof&#39;, accuracy), run_estimate(lof_test, primary = &#39;lof&#39;, accuracy) ) # tabel met data om threshold te plotten metric_tbl |&gt; pivot_wider(names_from = term, values_from = where(is.numeric)) |&gt; transmute( class = class, sensitivity = ci_paster( .estimate_sensitivity, .lower_sensitivity, .upper_sensitivity ), specificity = ci_paster( .estimate_specificity, .lower_specificity, .upper_specificity ), accuracy = ci_paster(.estimate_accuracy, .lower_accuracy, .upper_accuracy), mcc = ci_paster(.estimate_mcc, .lower_mcc, .upper_mcc), f1 = ci_paster(.estimate_f_meas, .lower_f_meas, .upper_f_meas) ) ## # A tibble: 3 × 6 ## class sensitivity specificity accuracy mcc f1 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 dn 0.519 [0.448,0.584] 0.778 [0.717,0.841] 0.642 [0.592,0.693] 0.306… 0.60… ## 2 gof 0.519 [0.45,0.592] 0.818 [0.759,0.879] 0.666 [0.619,0.712] 0.353… 0.61… ## 3 lof 0.519 [0.451,0.588] 0.815 [0.764,0.871] 0.66 [0.618,0.703] 0.348… 0.61… # threshold plots dn_thr &lt;- ggplot(dn_thresholds, aes(.threshold, .estimate, colour = .metric)) + geom_line(linewidth = 0.5, show.legend = TRUE) + scale_colour_viridis_d() + geom_vline(xintercept = pdn_threshold, colour = &#39;red&#39;) + geom_vline(xintercept = optimal_threshold(dn_thresholds), linetype = 2) + scale_y_continuous(labels = no_zero_trail) + scale_x_continuous(labels = no_zero_trail) + theme( legend.position = &#39;top&#39;, legend.direction = &#39;horizontal&#39;, legend.justification = &#39;left&#39;, legend.background = element_blank() ) + labs(x = &#39;pDN threshold&#39;, y = &#39;Metric estimate&#39;, colour = NULL) gof_thr &lt;- ggplot(gof_thresholds, aes(.threshold, .estimate, colour = .metric)) + geom_line(linewidth = 0.5, show.legend = FALSE) + scale_colour_viridis_d() + geom_vline(xintercept = pgof_threshold, colour = &#39;red&#39;) + geom_vline(xintercept = optimal_threshold(gof_thresholds), linetype = 2) + scale_y_continuous(labels = no_zero_trail) + scale_x_continuous(labels = no_zero_trail) + theme( legend.position = &#39;top&#39;, legend.direction = &#39;horizontal&#39;, legend.justification = &#39;left&#39;, legend.background = element_blank() ) + labs(x = &#39;pGOF threshold&#39;, y = &#39;Metric estimate&#39;, colour = NULL) lof_thr &lt;- ggplot(lof_thresholds, aes(.threshold, .estimate, colour = .metric)) + geom_line(linewidth = 0.5, show.legend = FALSE) + scale_colour_viridis_d() + geom_vline(xintercept = plof_threshold, colour = &#39;red&#39;) + geom_vline(xintercept = optimal_threshold(lof_thresholds), linetype = 2) + scale_y_continuous(labels = no_zero_trail) + scale_x_continuous(labels = no_zero_trail) + theme( legend.position = &#39;top&#39;, legend.direction = &#39;horizontal&#39;, legend.justification = &#39;left&#39;, legend.background = element_blank() ) + labs(x = &#39;pLOF threshold&#39;, y = &#39;Metric estimate&#39;, colour = NULL) dn_thr / gof_thr / lof_thr Allereerst heb ik bij de setup de regel setwd('path_to_OSF_storage/analysis') verwijderd. Er traden veel fouten op bij de pathways, dit kwam doordat de pathways eerst aangepast moesten worden naar mijn eigen paden. Zodra deze correct waren aangepast, ondervond ik geen problemen meer. Het was best zoeken naar de data en de functies binnen 1 analyse, in dit geval een threshold analyse. Naar mijn mening zou het handiger zijn om het per analyse te rangschikken, zodat iemand die het script wil reproduceren niet het volledige script hoeft uit te voeren. Het was namelijk behoorlijk lastig om alle benodigde data voor een specifieke analyse te filteren. Daarom lijkt het mij praktischer om per analyse te werken. Daarom lijkt het mij praktischer om per analyse te werken. Dit gebeurt nu al in zekere mate, maar dan zou ik aanraden om verplichte chunks in te stellen die eerst uitgevoerd moeten worden voordat een analyse start. De legenda ontbrak, maar is nu aanwezig doordat ik show.legend in geom_line heb aangepast. Hierdoor verschenen echter niet alle lijnen in de legenda. Ik heb geen idee hoe ik dit probleem had kunnen oplossen. Wat dat betreft vond ik het RMarkdown bestand vrij onoverzichtelijk. Voor de volledige reproduceerbaarheid geef ik het bestand een 3. 6.2.3 Referentie Artikel Badonyi M, Marsh JA (2024) Proteome-scale prediction of molecular mechanisms underlying dominant genetic diseases. PLoS ONE 19(8): e0307312. https://doi.org/10.1371/journal.pone.0307312. OSF https://osf.io/z4dcp/. "],["r-package.html", "7 R package", " 7 R package Voor dit onderdeel van mijn portfolio heb ik een eigen R package ontwikkeld, genaamd proteintools. proteintools bevat een aantal functies voor het analyseren van eiwit- en DNA sequenties, zoals het berekenen van de moleculaire massa van een eiwit, het tellen van aminozuren en de locatie hiervan teruggeven, een eiwitsequentie valideren en het vertalen van DNA naar eiwitsequenties. Download proteintools met de volgende code: devtools::install_github(\"jetskemoot/proteintools\", dependencies = TRUE, build_vignettes = TRUE) Bekijk vignette met: browseVignettes(\"proteintools\") "],["projecticum-alternative-splicing-scrna-seq.html", "8 Projecticum alternative splicing scRNA-seq", " 8 Projecticum alternative splicing scRNA-seq Alternative splicing is een proces waar axonen van hetzelfde gen worden gecombineerd in verschillende combinaties, maar uiteindelijk leiden tot een ander mRNA transcript. Het proces om exonen selectief te combineren leidt uiteindelijk naar het ontstaan van eiwitten met verschillende functies [@baralleSplicingCode2018]. Verstoringen in alternatieve splicing zijn in verband gebracht met diverse ziekten, waaronder kanker, neurodegeneratieve aandoeningen en ontwikkelingsstoornissen [@pengImpactsMechanismsAlternative2022]. Single cell RNA sequencing (scRNA-seq) is een technologie die het mogelijk maakt om genexpressie te bestuderen op het niveau van individuele cellen. scRNA-seq meet dus voor het hele transcriptoom de genexpressie van een individuele cel. Hierdoor is het mogelijk om gedetailleerd te kijken naar de functie van de cellen [@BeginnersGuideBuilding]. Hoewel scRNA-seq voornamelijk wordt gebruikt voor differentiële genexpressie analyse en clustering, biedt het daarnaast een unieke mogelijkheid om alternatieve splicing op enkelcellig niveau te bestuderen. In dit project wordt een geautomatiseerde en reproduceerbare workflow ontwikkeld voor het detecteren en analyseren van alternatieve splicing in scRNA-seq data. De workflow maakt gebruik van Seurat, een veelgebruikt R package voor de voorbewerking, normalisatie, visualisatie en clustering van scRNA-seq data [@ToolsSingleCell]. Na het identificeren van celclusters en genexpressie met Seurat wordt de alternatieve splicing geanalyseerd met behulp van drie gespecialiseerde tools, namelijk Whippet, SUPPA2 en BRIE2. Whippet is een tool voor het analyseren van alternative splicing in RNA-seq data. Het is ontworpen voor snelle en nauwkeurige kwantificatie van splicing events [@sterne-weilerTimbitzWhippetjl2025]. SUPPA2 is ook een tool voor het analyseren van alternative splicing in RNA-seq data. Het maakt gebruik van transcriptkwantificatie om splicing events te identificeren en te vergelijken tussen verschillende biologische condities [@ComprnaSUPPA2025]. Tenslotte is ook BRIE2 specifiek ontwikkeld voor splicing analyse in scRNA-seq data. Het gebruikt een Bayesiaans model om splicing events te koppelen aan celkenmerken zoals celtype of ziekte [@BRIE2ComputationalIdentification]. Door deze tools met elkaar te vergelijken binnen dezelfde dataset kan worden geëvalueerd welke het meest geschikt is voor het detecteren van splicing. "],["ecdc-covid-19-geparametriseerd-rapport.html", "9 ECDC COVID-19 geparametriseerd rapport 9.1 YAML header van geparametriseerd COVID-19 rapport 9.2 Codes in geparametriseerd COVID-19 rapport", " 9 ECDC COVID-19 geparametriseerd rapport Voor dit onderdeel van mijn portfolio heb ik een geparametriseerd RMarkdown rapport gemaakt waarin COVID-19 data van de ECDC (European Centre for Disease Prevention and Control) visueel wordt weergegeven op basis van drie instelbare parameters: het land, het jaar en de maand van interesse. Het is een flexibel rapport dat automatisch de juiste gegevens filtert en grafieken toont voor zowel het aantal nieuwe COVID-19 gevallen als het aantal sterfgevallen in de geselecteerde periode. 9.1 YAML header van geparametriseerd COVID-19 rapport Binnen een Bookdown project kan geen gebruik worden gemaakt van een RMarkdown bestand met een YAML header die parameters bevat. Hieronder laat ik zien wat er in de YAML header staat van het ECDC COVID-19 geparametriseerd rapport in een RMarkdown bestand dat buiten mijn Bookdown repository is aangemaakt. --- title: &quot;COVID-19 cases and deaths&quot; output: html_document params: country: &quot;Netherlands&quot; year: 2021 month: 5 --- 9.2 Codes in geparametriseerd COVID-19 rapport Omdat er geen gebruik kan worden gemaakt van een YAML header met parameters, is parameterisatie binnen de code chunks in dit Bookdown bestand niet mogelijk. In de code wordt met een comment laten zien wat de oorspronkelijke code is in het originele bestand. library(dplyr) library(plotly) # data downloaden data &lt;- read.csv(&quot;https://opendata.ecdc.europa.eu/covid19/nationalcasedeath_eueea_daily_ei/csv&quot;, na.strings = &quot;&quot;, fileEncoding = &quot;UTF-8-BOM&quot;) # data op parameters van interesse covid_subset &lt;- data |&gt; filter(countriesAndTerritories == &quot;Netherlands&quot;, year == 2021, month == 5) # in origineel RMarkdown bestand # covid_subset &lt;- data |&gt; # filter(countriesAndTerritories == params$country, # year == params$year, # month == params$month) # bar plot maken van aantal nieuwe COVID-19 cases covid_subset |&gt; plot_ly(x = ~dateRep, y = ~cases, type = &quot;bar&quot;, text = ~paste(&quot;Date:&quot;, dateRep, &quot;&lt;br&gt;Cases:&quot;, cases), hoverinfo = &quot;text&quot;) |&gt; layout(title = (&quot;New reported COVID-19 cases in Netherlands in May 2021&quot;), xaxis = list(title = &quot;Date&quot;, tickfont = list(size = 7)), yaxis = list(title = &quot;New reported cases&quot;)) # in origineel RMarkdown bestand # covid_subset |&gt; # plot_ly(x = ~dateRep, # y = ~cases, # type = &quot;bar&quot;, # text = ~paste(&quot;Date:&quot;, dateRep, &quot;&lt;br&gt;Cases:&quot;, cases), # hoverinfo = &quot;text&quot;) |&gt; # layout(title = paste(&quot;New reported COVID-19 cases in&quot;, params$country, &quot;in&quot;, month.name[params$month], params$year), # xaxis = list(title = &quot;Date&quot;, tickfont = list(size = 7)), # yaxis = list(title = &quot;New reported cases&quot;)) # bar plot maken van aantal nieuwe sterfgevallen covid_subset |&gt; plot_ly(x = ~dateRep, y = ~deaths, type = &quot;bar&quot;, text = ~paste(&quot;Date:&quot;, dateRep, &quot;&lt;br&gt;Deaths:&quot;, deaths), hoverinfo = &quot;text&quot;) |&gt; layout(title = paste(&quot;COVID-19 deaths in Netherlands in May 2021&quot;), xaxis = list(title = &quot;Date&quot;, tickfont = list(size = 7)), yaxis = list(title = &quot;Number of Deaths&quot;)) # in origineel RMarkdown bestand # covid_subset |&gt; # plot_ly(x = ~dateRep, # y = ~deaths, # type = &quot;bar&quot;, # text = ~paste(&quot;Date:&quot;, dateRep, &quot;&lt;br&gt;Deaths:&quot;, deaths), # hoverinfo = &quot;text&quot;) |&gt; # layout(title = paste(&quot;COVID-19 deaths in&quot;, params$country, &quot;in&quot;, month.name[params$month], params$year), # xaxis = list(title = &quot;Date&quot;, tickfont = list(size = 7)), # yaxis = list(title = &quot;Number of Deaths&quot;)) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
